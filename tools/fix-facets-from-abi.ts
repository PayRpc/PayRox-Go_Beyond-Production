import fs from "fs";
import path from "path";
import { JsonFragment, id } from "ethers";

// Usage:
//   ts-node tools/fix-facets-from-abi.ts \
//     --abi artifacts/.../Monolith.json (optional) \
//     --manifest split-output/selectors.json \
//     --out contracts/facets-fixed

type SelectorEntry = {
  signature: string;
  selector: string;
  facet: string;
  contractName?: string;
  stateMutability?: string;
  type?: string;
};

type SelectorsFile = {
  selectors: SelectorEntry[];
};

function parseArgs() {
  const raw = process.argv.slice(2);
  const args: Record<string, string> = {};
  for (let i = 0; i < raw.length; i += 2) {
    const k = raw[i];
    const v = raw[i + 1];
    if (!k?.startsWith("--") || v === undefined) {
      continue;
    }
    args[k.replace(/^--/, "")] = v;
  }
  return args;
}

function readJSON<T = any>(fp: string): T {
  return JSON.parse(fs.readFileSync(fp, "utf8")) as T;
}

function listFilesRecursive(dir: string, predicate: (_p: string) => boolean): string[] {
  const out: string[] = [];
  const stack = [dir];
  while (stack.length) {
    const d = stack.pop()!;
    if (!fs.existsSync(d)) continue;
    const entries = fs.readdirSync(d, { withFileTypes: true });
    for (const e of entries) {
      const p = path.join(d, e.name);
      if (e.isDirectory()) stack.push(p);
      else if (predicate(p)) out.push(p);
    }
  }
  return out;
}

function solType(i: any): string {
  // Handles tuples and arrays
  const t: string = i.type;
  const isArray = t.endsWith("[]");
  const base = isArray ? t.slice(0, -2) : t;
  if (base === "tuple") {
    const comps = (i.components || []).map((c: any) => solType(c)).join(", ");
    return `(${comps})${isArray ? "[]" : ""}`;
  }
  return t;
}

function genFn(item: JsonFragment, enforcedMutability?: string): string {
  const name = item.name!;
  const inputs = (item.inputs || []).map((inp, idx) => {
    let t = solType(inp);
    // Add data location for dynamic types in external functions
    const needsLoc = /^(bytes|string)(\[\])?$/.test(t) || t.endsWith("[]") || t.startsWith("(\n") || t.startsWith("(");
    if (needsLoc && !t.includes(" memory") && !t.includes(" calldata")) {
      t = `${t} calldata`;
    }
    const n = inp.name && inp.name.length ? inp.name : `arg${idx}`;
    return `${t} ${n}`;
  }).join(", ");

  // Outputs: flatten plain tuples into individual return values for valid Solidity syntax
  const outFrags = item.outputs || [];
  const flattened: string[] = [];
  if (outFrags.length === 1 && (outFrags[0] as any).type?.startsWith("tuple") && !(outFrags[0] as any).type?.endsWith("[]")) {
    const comps = (outFrags[0] as any).components || [];
    for (let i = 0; i < comps.length; i++) {
      const c = comps[i];
      let t = solType(c);
      const n = c.name && c.name.length ? c.name : `ret${i}`;
      flattened.push(`${t} ${n}`);
    }
  } else {
    for (let i = 0; i < outFrags.length; i++) {
      const o = outFrags[i] as any;
      let t = solType(o);
      if (t === "bytes" || t === "string" || t.endsWith("[]") || t.startsWith("(\n") || t.startsWith("(")) {
        t = `${t} memory`;
      }
      const n = o.name && o.name.length ? o.name : `ret${i}`;
      flattened.push(`${t} ${n}`);
    }
  }
  const returns = flattened.length ? ` returns (${flattened.join(", ")})` : "";

  const mut = enforcedMutability ?? (item.stateMutability as string | undefined) ?? "nonpayable";
  const mutStr = mut === "view" ? " view" : mut === "pure" ? " pure" : mut === "payable" ? " payable" : "";

  return `    function ${name}(${inputs}) external${mutStr}${returns} {\n        revert("TODO: migrate");\n    }`;
}

function genFacet(name: string, items: JsonFragment[]): string {
  const header = `// SPDX-License-Identifier: MIT\npragma solidity 0.8.30;\n\n/**\n * @title ${name}\n * @notice Autogenerated ABI-accurate stub facet (PayRox)\n * @dev Generated from ABI + selectors manifest; bodies intentionally revert.\n */\nlibrary ${name}Storage {\n    bytes32 internal constant SLOT = keccak256("payrox.facets.${name}.v1");\n    struct Layout { uint256 __reserved; }\n    function layout() internal pure returns (Layout storage l) { bytes32 p = SLOT; assembly { l.slot := p } }\n}\n\ncontract ${name} {\n`;
  const body = items.map((it) => genFn(it)).join("\n\n");
  const tail = `\n}\n`;
  return header + body + tail;
}

function main() {
  const args = parseArgs();
  const manifestPath = args.manifest;
  const outDir = args.out;
  const abiPath = args.abi; // optional

  if (!manifestPath || !outDir) {
    console.error("Usage: ts-node tools/fix-facets-from-abi.ts --manifest split-output/selectors.json --out contracts/facets-fixed [--abi artifacts/.../Monolith.json]");
    process.exit(1);
  }

  const selFile = readJSON<SelectorsFile>(manifestPath);
  const selectorEntries = (selFile.selectors || []).filter((s) => s.type === "function");

  // Build ABI source: from provided ABI file or from artifacts
  let abi: JsonFragment[] = [];
  if (abiPath) {
    const monolith = readJSON<any>(abiPath);
    abi = monolith.abi as JsonFragment[];
  } else {
    // Fallback: scan all artifact ABIs
    const artifactFiles = listFilesRecursive(path.resolve("artifacts/contracts"), (p) => p.endsWith(".json") && !p.endsWith(".dbg.json"));
    for (const fp of artifactFiles) {
      try {
        const j = readJSON<any>(fp);
        if (Array.isArray(j.abi)) {
          abi.push(...(j.abi as JsonFragment[]));
        }
      } catch {
        // ignore bad json files
      }
    }
  }

  // Interface for selector calc
  const bySelector = new Map<string, JsonFragment>();
  for (const frag of abi) {
    if (frag.type === "function" && frag.name) {
      try {
  // Build canonical signature: name(types)
  const types = (frag.inputs || []).map((i) => solType(i)).join(",");
  const signature = `${frag.name}(${types})`;
        const sel = id(signature).slice(0, 10).toLowerCase();
        bySelector.set(sel, frag);
      } catch {
        // skip
      }
    }
  }

  // Group ABI fragments per facet from manifest
  const groups = new Map<string, JsonFragment[]>();
  for (const ent of selectorEntries) {
    const sel = ent.selector.toLowerCase();
    const frag = bySelector.get(sel);
    if (!frag) {
      console.error(`Selector not found in ABI: ${sel} (${ent.signature})`);
      process.exitCode = 2;
      continue;
    }
    // Skip anti-bot interface and non-standard loupe helper if it appears
    if (ent.facet === "IAntiBotFacet") continue;
    if (ent.signature?.startsWith("getFacetFunctionSelectors")) continue;
    const facetName = ent.facet;
    if (!facetName) continue;
    if (!groups.has(facetName)) groups.set(facetName, []);
    groups.get(facetName)!.push(frag);
  }

  // Deterministic order and emit files
  fs.mkdirSync(outDir, { recursive: true });
  let written = 0;
  for (const [name, items] of groups) {
    // sort by selector for determinism
    const itemsSorted = items
      .slice()
      .sort((a, b) => {
        const ta = (a.inputs || []).map((i) => solType(i)).join(",");
        const tb = (b.inputs || []).map((i) => solType(i)).join(",");
        const sa = id(`${a.name}(${ta})`).slice(0, 10).toLowerCase();
        const sb = id(`${b.name}(${tb})`).slice(0, 10).toLowerCase();
        return sa.localeCompare(sb);
      });
    const code = genFacet(name, itemsSorted);
    const fp = path.join(outDir, `${name}.sol`);
    fs.writeFileSync(fp, code);
    console.log("wrote", fp);
    written++;
  }

  if (process.exitCode && process.exitCode !== 0) {
    console.error("Completed with missing selectors; see errors above.");
    process.exit(process.exitCode);
  } else {
    console.log(`âœ… Generated ${written} facet stubs in ${outDir}`);
  }
}

main();
